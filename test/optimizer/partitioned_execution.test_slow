# name: test/optimizer/partitioned_execution.test_slow
# description: Test the PartitionedExecution optimizer
# group: [optimizer]

load __TEST_DIR__/partitioned_execution.duckdb

# create test table with doubles instead of integers to avoid compressed materialization
statement ok
CREATE TABLE test AS
SELECT
    CAST(range // 2_000_000 AS DOUBLE) AS t_low_cardinality_ordered,
    CAST(range // 10 AS DOUBLE) AS t_high_cardinality_ordered,
    CAST(range % 10 AS DOUBLE) AS t_low_cardinality_recurring,
    CAST(range % 3_000_000 AS DOUBLE) AS t_high_cardinality_recurring,
    CAST(42 AS DOUBLE) AS t_const
FROM range(10_000_000);

# compute order-agnostic hash, is used to make sure we don't scan rows multiple times or miss scanning rows
query I nosort h
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM test;
----

statement ok
pragma explain_output='optimized_only'

# this optimizer splits pipelines based on the number of active threads
# if there are many pipelines, we want larger splits to achieve good parallel CPU utilization
# we set threads to 1 so we can test the functionality with a relatively small amount of data
statement ok
SET threads=1;

# optimization works when ordering/grouping/windowing by these columns individually
foreach c t_low_cardinality_ordered t_high_cardinality_ordered t_high_cardinality_recurring

# ORDER BY, test both sort orders
foreach order_type ASC DESC

# should see a union here
query II
EXPLAIN WITH cte AS (
    FROM test ORDER BY ${c} ${order_type}
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----
logical_opt	<REGEX>:.*UNION.*

# hash should be the same
query I nosort h
WITH cte AS (
    FROM test ORDER BY ${c} ${order_type}
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----

endloop

# GROUP BY
query II
EXPLAIN WITH cte1 AS (
    SELECT ${c}, list(test) l
    FROM test GROUP BY ALL
), cte2 AS (
    SELECT unnest(l, recursive := true)
    FROM cte1
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte2;
----
logical_opt	<REGEX>:.*UNION.*

query I nosort h
WITH cte1 AS (
    SELECT ${c}, list(test) l
    FROM test GROUP BY ALL
), cte2 AS (
    SELECT unnest(l, recursive := true)
    FROM cte1
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte2;
----

# WINDOW
query II
EXPLAIN WITH cte AS (
    SELECT ROW_NUMBER() OVER (PARTITION BY ${c}) AS idx, *
    FROM test
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----
logical_opt	<REGEX>:.*UNION.*

query I nosort h
WITH cte AS (
    SELECT ROW_NUMBER() OVER (PARTITION BY ${c}) AS idx, *
    FROM test
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----


endloop

# continue with multi-column stuff
# const/ordered, we can split for ORDER BY because t_const min == max
query II
EXPLAIN WITH cte AS (
    FROM test ORDER BY t_const, t_high_cardinality_recurring
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----
logical_opt	<REGEX>:.*UNION.*

query II nosort h
WITH cte AS (
    FROM test ORDER BY t_const, t_high_cardinality_recurring
)
SELECT bit_xor(hash(*COLUMNS('^t_')))
FROM cte;
----


# TODO more tests, make sure the order is correct too